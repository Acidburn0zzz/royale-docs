---
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
# 
# http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

layout: docpage
title: Modules
---

# Modules

Royale supports a distributed development model called Modules.  Those familiar with Apache Flex will recognize the term.  Royale modules work almost identically to Flex modules with a few differences.

## Why Modules?

As your application grows in size, it means you will by default be loading more and more code just to show the first screen of your application.  In many cases, a complex application will have many screens.  The first screen may just be a login screen, for example.  If your users may be on slow or busy (or expensive) networks, you will want to load as little code as possible to show the first screen and load other code in the background or on-demand.

Also, as your application grows in size, the number of files of code you are writing will probably grow as well and compile-time will increase.  And, you may have teammates helping develop some of these files.  Having to coordinate changes in the various files and wait for long compile-times is expensive.  If you have properly designed your application, you will know that not every file needs to be re-compiled when other files change, so having one teammate work on one set of files while you work on another saves time and hassle.

A Module is a separate compilation session of one or more source files that results in output that can be loaded later by the main application.

A module can contain code that doesn't have an UI or it can be mostly UI.  Modules are most commonly used to load other UI screens and associated UI logic.  There is a ModuleLoader component that will display the UI components that are children of a Module.  MXML files are commonly used to specify the UI components.  There is an example in the examples/royale/ModuleExample folder.

Proper use of modules can help maintain "separation of concerns" which helps keep you from writing "spaghetti code".  If only the code in one module changes, only that module needs to be recompiled.  And if that code isn't needed to show the first screen, then the application will start up faster.

## Compiling modules

Typically, a Module is developed in a separate folder of source files and the output is generated as a sibling to those source files, which then cannot be easily access by the output of the main app.  In JavaScript output, in development mode, lots of files are generated by the compiler.  All of these files must be relocated into the main app's output folder so that the main app can reference it via the same relative path when the module is compiled into a single output file in production mode.  The Royale compiler supports a -module-output=<destination folder> that redirects where the output goes in order to place the development output in the right place.

## Using modules

Modules are loaded by specifying the path to the main JavaScript file for the module.  If you are also working with Flash/AIR output, you can specify the .swf suffix and the Royale ModuleLoader will replace that with .js as needed.

## Differences from Flex modules

A potentially important difference between Flex modules and Royale modules is how memory is managed.  The Flash/AIR runtimes support the concept of unloadable code via a class called ApplicationDomain.  If you load a SWF in Flash or AIR and then remove all references to its code and instances, the SWF and the code definitions will be freed from memory.

There is currently no emulation of ApplicationDomain in Royale.  Royale modules all load into the same global variable scope as the main application.  It might be possible to emulate ApplicationDomain, but it will likely be expensive.  The benefit of having unloadable code in JavaScript may not be as compelling as for Flash/AIR.  In Flash, SWFs are compressed binaries so they cannot be further compressed when downloaded over the network.  The code in a SWF was an intermediate byte code instead of plain text that has been minified.  And Flash always JIT-compiled the intermediate byte code.  Different browsers will have different behaviors when interpreting JavaScript.  And, seeing the module unload was a good test that all of the instances associated with the module have been freed.  But it was almost always true that the amount of memory allocated to these instances was much more than the overhead of the code itself.  So, the cost of leaving class definitions in global memory plus the memory for the actual module's JavaScript source may not be the reason your application runs out of memory.  The real trick will be determining what instances are still stuck in memory and how to get rid of them.


